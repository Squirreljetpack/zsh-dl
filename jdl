#!/bin/zsh

# https://github.com/sumoduduk/terminusdm

### CONSTANTS

: ${ZSHDL_CONNECT_TIMEOUT:=5}
: ${ZSHDL_THREADS:=5}
: ${ZSHDL_PP_THREADS:=5}
[[ $VERBOSE == [0-9] ]] || VERBOSE=1

: ${ZSHDL_FORCE_PROTO}
: ${ZSHDL_OUTPUT_DIR:=./}
: ${ZSHDL_LOG_DISPLAY_LIMIT:=50}

: ${ZSHDL_STATE_DIR:=$HOME/.local/state/zsh-dl}
ZSHDL_DB=$ZSHDL_STATE_DIR/log.db
: ${ZSHDL_CONFIG_DIR:=$HOME/.config/zsh-dl}
PROTOCOLS=(HTTP SSH FILE NA)

# (Line Status) LS_CODES
# 0: Unprocessed/Unhandled
# 1: Handling
# 2: HandlerError
# 3: HandlerSuccess
# 4: PPError
# 5: PPSuccess
# 6: InternalError

exportCmdVar() {
  local var_name=$1
  shift
  for param; do
    if (( $+commands[${param%% *}] )); then
      typeset -gx "$var_name=$param"
      return 0
    fi
  done
  typeset -gx "$var_name=false"
  return 1
}

exportCmdVar "CLIPcmd" \
  "xclip -sel clip" \
  "pbcopy"

exportCmdVar "PASTEcmd" \
  "xclip -o" \
  "pbpaste"

exportCmdVar "FORMATPYTHONcmd" \
  "ruff"

exportCmdVar "HTML2MARKDOWNcmd" \
  "html2markdown" \
  "html-to-markdown"

unset -f exportCmdVar

setopt extended_glob

### HANDLERS

# entrypoint

handle_pretransform() {
  proto=${1%%://*}
  stem=${1#*://}
  if [[ -n $ZSHDL_FORCE_PROTO ]]; then
    proto=$ZSHDL_FORCE_PROTO
  elif [[ $proto == $stem ]]; then
    proto=
  fi
  echo $proto
  echo $stem
}

handle() {
  export LS=0
  export LINE=$1
  handle_pretransform $1 | {
    read -r proto
    read -r stem
  }
  exec {lg}> $LG

  # 

  ((VERBOSE>1)) && info proto

  case $proto in
    http(|s))
      handle_http $stem
      ;;
    ssh)
      handle_ssh $stem
      ;;
    sftp)
      handle_ssh $stem
      ;;
    file)
      handle_file $stem
      ;;
    *)
      handle_na $LINE
      return
    ;;
  esac
}

internal_err() {
  err "InternalError" ${funcstack[2]}
  exit 1
}

handle_http() {
  url=$1
  if [[ $url == *"?"* ]]; then
    params=${url#*"?"}
    url=${url%%"?"*}
  fi
  shift 1

  info url
  [[ -n $params ]] && info params


  while IFS='=' read -r _handler pattern; do
    patterns=(${(s.:.)pattern})
    if [[ $url == $~patterns[1] ]] && 
    [[ (($#patterns < 2)) || $params == $~patterns[2] ]]; then
      LS=1
      handler=${_handler%:*}
      method=${_handler#$handler}
      is_function $handler || internal_err
      dest=$($handler $url $params) &&
      __submit_pp $handler $dest $method
      return
    fi
  done <<< $HTTP_HANDLERS

  internal_err
}

handle_ssh() {
  exec 3>&1 > /dev/null
  
  target=$1
  subpath=${${1#*:}%.git}
  userhost=${1%%:*}
  shift 1

  info target userhost subpath

  while IFS='=' read -r _handler pattern; do
    patterns=(${(s.:.)pattern})
    if [[ $target == $~patterns[1] ]] && 
    [[ (($#patterns < 2)) || $userhost == $~patterns[2] ]] &&
    [[ (($#patterns < 3)) || $subpath == $~patterns[3] ]]; then
      LS=1
      handler=${_handler%:*}
      method=${_handler#$handler}
      is_function $handler || internal_err
      dest=$($handler $userhost $subpath) &&
      __submit_pp $handler $dest $method
      return
    fi
  done <<< $SSH_HANDLERS

  internal_err
}

handle_file() {
  target=$1

  if [[ ! -e $target && ! -L $target ]]; then
     err "Nonexistant" $target
     return 1
  fi

	type=$(_get_file_type $target)
  res="$(file -bI $target)"
	mime=${res%%\; *}
	encoding=${res#*\; }
  shift 1

  info target type mime encoding
	
  while IFS='=' read -r _handler pattern; do
	  patterns=(${(s.:.)pattern})
    if [[ $target == $~patterns[1] ]] && 
    [[ (($#patterns < 2)) || $type == $~patterns[2] ]] &&
    [[ (($#patterns < 3)) || $mime == $~patterns[3] ]] &&
    [[ (($#patterns < 4)) || $encoding == $~patterns[4] ]]; then
      LS=1
      handler=${_handler%:*}
      method=${_handler#$handler}
      is_function $handler || internal_err
      dest=$($handler $target $type $mime $encoding) &&
      __submit_pp $handler $dest
      return
    fi
	done <<< $FILE_HANDLERS

  internal_err
}

handle_na() {
  target=$1
  shift 1

  if [[ -e $target ]]; then
    handle_file $target
    return
  elif [[ $target =~ '^[a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+:.+$' ]]; then
    handle_ssh $target
    return
  else
    while IFS='=' read -r _handler pattern; do
      if [[ $target == $~pattern ]]; then
        [[ $_handler != na.default ]] && LS=1
        handler=${_handler%:*}
        method=${_handler#$handler}
        is_function $handler || internal_err
        dest=$($handler $target) &&
        __submit_pp $handler $dest $method
        return
      fi
    done <<< $NA_HANDLERS
  fi
  
  internal_err
}

#### API

## Handler Defaults
http.default() {
  target=$1
  dest="$(_get_dest http $target)"
  [[ $target != http(|s)://* ]] && target="https://$target"
  [[ -n $2 ]] && target+="?$2"
  info dest
  shift 1
  
  case $dest in
    *)
      opts=()
      if [[ -e $dest ]] && curl -I $target | grep -qi accept-ranges; then
        opts+=(-C - -O) # continue at end, original filename
      else
        opts+=(-o $dest)
      fi
      
      _success_or_log curl -fL $opts $target || return
      ;;
  esac
  
  echo $dest
}

ssh.default() {
  dest=$(_get_dest ssh $1)
  success_or_log rsync -e "ssh -o ConnectTimeout=$ZSHDL_CONNECT_TIMEOUT" -avucz $1 $dest # -u does an update in case we decided to keep the target
}

file.default() {
  echo $1
}

na.default() {
  warn Unhandled "\"$1\""
  return 1
}

## Getters

_get_dest() {
  proto=$1
  shift 1
  case $proto in
    http(|s))
      dest=${${1%/\#[^\#/]##}:t} # strip #id
      [[ -z $dest:e ]] && dest+=.html
      mktarget -d ${@:2} $ZSHDL_OUTPUT_DIR$dest
      ;;
    ssh)
      subpath=${${1##*:}%.git}
      dest=$subpath:t
      mktarget -d ${@:2} $ZSHDL_OUTPUT_DIR$dest
      ;;
    (|s)ftp)
      dest=$1:t
      mktarget -d ${@:2} $ZSHDL_OUTPUT_DIR$dest
      ;;
    file)
      dest=$1:t
      mktarget -d ${@:2} $ZSHDL_OUTPUT_DIR$dest
      ;;
    *)
      return 1
    ;;
  esac
}

_get_html_field() {
  sed -n 's:.*<$field>\(.*\)</$field>.*:\1:p' $1 | tr -cd '[a-zA-Z0-9 -_[]()]'
}

_get_file_type() {
  # provides a char from fdsbcxesp for file, directory, symlink, block-device, char-device, executable, empty, socket, pipe
  if [[ -L $1 ]]; then
    echo "l"
  elif [[ -d $1 ]]; then
    echo "d"
  elif [[ -b $1 ]]; then
    echo "b"
  elif [[ -c $1 ]]; then
    echo "c"
  elif [[ -S $1 ]]; then
    echo "s"
  elif [[ -p $1 ]]; then
    echo "p"
  elif [[ -f $1 ]]; then
    if [[ ! -s $1 ]]; then
      echo "e"
    elif [[ -x $1 ]]; then
      echo "x"
    else
      echo "f"
    fi
  else
    echo "u"
  fi
}

## Utils

err() {
  # make error red
  print -u2 -- "[ERROR: $1] $2"
  [[ -n $LINE ]] && _log_msg "[ERROR: $1] $2"
}

warn() {
  # make orange
  ((VERBOSE)) || return
  print -u2 -- "[WARN: $1] $2"
  _log_msg "[WARN: $1] $2"
}

info() {
  ((VERBOSE)) || return
  # make info blue
  while (($#)); do
    print -u2 -- "[INFO: $1] ${(P)1}"
    ((VERBOSE>1)) && _log_msg "[INFO: $1] ${(P)1}"
    shift 1
  done
}

dbg() {
  ((VERBOSE>1)) && print -u2 -- "[DEBUG] $1"
}

is_function() {
  [[ -n ${functions[$1]} ]]
}
## Display logs

# Strips ANSI codes to get the real string length
__get_visible_length() {
  local str_no_ansi
  str_no_ansi=${(S)1//(#m)\x1b\[[0-9;]*m/}
  print -n ${#str_no_ansi}
}

# Centers text within a given width
__center_text() {
  local text=$1
  local width=$2
  local len
  len=$(__get_visible_length $text)
  local pad_len=$(( (width - len) / 2 ))
  local remainder=$(( (width - len) % 2 ))
  printf "%*s%s%*s" $pad_len "" $text $((pad_len + remainder)) ""
}

__truncate_right() {
  local text=$1
  local width=$2
  if (( $(__get_visible_length $text) > width )); then
    print -n -- "${text:0:$((width-3))}..."
  else
    printf "%-*s" $width $text
  fi
}

__truncate_left() {
  local text=$1
  local width=$2
  if (( $(__get_visible_length $text) > width )); then
    print -n -- "...${text:$(($#text-width))}"
  else
    printf "%*s" $width $text
  fi
}

_get_LS_color() {
  case $1 in
    0) print -n '\033[90m' ;;      # Muted Grey (for Unprocessed/Unhandled)
    1) print -n '\033[37m' ;;      # White (for Handling)
    2|6) print -n '\033[31m' ;;    # Bright Red (for HandlerError & InternalError)
    3) print -n '\033[32m' ;;      # Green (for HandlerSuccess)
    4) print -n '\033[38;5;203m' ;; # Softer Red/Salmon (for PPError)
    5) print -n '\033[34m' ;;      # Blue (for PPSuccess)
    *) print -n '\033[37m' ;;      # Default to White for any other status
  esac
}

__show_log() {
  if [[ ! -f $ZSHDL_DB ]]; then
    err show_log "Database not found: $ZSHDL_DB"
    return 1
  fi

  local data
  data=$(sqlite3 $ZSHDL_DB -separator $'\t' \
    "SELECT LS, target, COALESCE(msg, ' '), COALESCE(dest, ' ')
     FROM log
     ORDER BY id DESC
     LIMIT $ZSHDL_LOG_DISPLAY_LIMIT")

  if [[ -z $data ]]; then
    warn show_log No log entries found
    return 0
  fi

  data=${data//$'\t'http(|s):\/\/(www.|)/$'\t'}

  local headers=$'St.\tTarget\tMessage\tDestination'
  local all_data=${headers}$'\n'${data}

  local -a col_widths
  # CORRECTED: Use a 'herestring' (<<<) to pipe data to awk safely.
  # This prevents the shell from breaking the tab characters.
  col_widths=($(awk -F'\t' '
  {
    for(i=1; i<=NF; i++) {
      gsub(/\x1b\[[0-9;]*m/, "", $i)
      len = length($i)
      if (len > max[i]) max[i] = len
    }
  }
  END {
    w1 = (max[1]<4)?4:max[1]; printf "%d ", w1;
    w2 = (max[2]<10)?10:max[2]; w2 = (w2>40)?40:w2; printf "%d ", w2;
    w3 = (max[3]<10)?10:max[3]; w3 = (w3>40)?40:w3; printf "%d ", w3;
    w4 = (max[4]<20)?20:max[4]; w4 = (w4>60)?60:w4; printf "%d ", w4;
  }' <<< $all_data))

  # --- Build and Print Table ---
  local reset_color=$'\033[0m'
  local top_border=+
  local sep_border=+
  local bot_border=+

  for i in $col_widths; do
    local w="$i"
    local line="$(printf "%*s" $((w + 2)) "" | tr ' ' '-')" # strangely, local line on its own produces output!
    top_border+="${line}+"
    sep_border+="${line}+"
    bot_border+="${line}+"
  done


  # Print Header
  print "\nLast $ZSHDL_LOG_DISPLAY_LIMIT Log Entries"
  print $top_border
  printf "| %s | %s | %s | %s |\n" \
    "$(__center_text 'St.' ${col_widths[1]})" \
    "$(__center_text 'Target' ${col_widths[2]})" \
    "$(__center_text 'Message' ${col_widths[3]})" \
    "$(__center_text 'Destination' ${col_widths[4]})"
  print $sep_border

  # Print Data Rows
  while IFS=$'\t' read -r ls target msg dest; do
    local color="$(_get_LS_color $ls)"
    local ls_str="$(__center_text $ls ${col_widths[1]})"
    local target_str="$(__truncate_right $target ${col_widths[2]})"
    local msg_str="$(__truncate_right $msg ${col_widths[3]})"
    local dest_str="$(__truncate_left $dest ${col_widths[4]})"

    printf "| %s%s%s | %s | %s | %s |\n" \
      $color $ls_str $reset_color \
      $target_str  \
      $msg_str \
      $dest_str
  done <<< $data

  print $bot_border
}

#### POSTPROCESSORS

# entrypoint
__begin_pp() {
  tasks=()
  while IFS=$'\0' read -r file method LINE; do
    (($#tasks >= $ZSHDL_PP_THREADS)) && __wait_any
    if [[ -z $method ]]; then
      LS=3
      _log_dest $file
    elif is_function pp_$method; then
      LS=5
      _log_dest $(pp_$method $file)
    else
      LS=6
      err InvalidPostprocessingMethod "$method for $file"
      echo $file
    fi &
    tasks+=$!
  done < $1
}

__submit_pp() {
  # Args: handler dest (created filename) [method]
  LS=3
  _log_dest $2 >/dev/null
  [[ -z $2 ]] && err InvalidName "Empty filename"

  
  if method=$3 && [[ -n $method ]]; then
    [[ $2 == *$'\0'* ]] &&
      err InvalidName "Files cannot contain null characters ($2)" &&
      return 1
      
    echo $2$'\0'$method$'\0'$LINE >&$pp &&
    _log_msg "[PP: $method] invoked for $dest"

  elif method=${1#*.} && [[ -n ${functions[pp_$method]} ]]; then
    [[ $2 == *$'\0'* ]] &&
      err InvalidName "Files cannot contain null characters ($2)" &&
      return 1
    
    echo $2$'\0'$method$'\0'$LINE >&$pp &&
    _log_msg "[PP: $method] invoked for $dest"

  else
    echo $2
  fi
}



### BEGIN LOGIC


# use _success_or_log ..cmd || return on critical commands
_success_or_log() {
  result=$($@ 2> >(tee /dev/fd/2))
  code=$?
  if ((code)); then
    LS=2 TAG=${TAG:-$1} _log_msg $result
    return $code
  fi
  # need sqlite db
  # todo: better logging (replace /dev/null)
  # something like: target, dest, msg, LS (unhandled, failed, pp error, success)
  # problem is capturing msg to stderr and processing - can use &> | tee /dev/fd/$myfd, just not sure if we want stdout of any of git clone/rsync/curl.
  # probably best is to have a seperate log file for each file which is written to, the file is renamed based on LS code
  #... since we can submit target+dest and have the logger look for dest to replace with pp.
}

__wait_any() {
  while true; do
    for (( i=1; i<=$#tasks; i++ )); do;
      if ! kill -0 $tasks[i] 2>/dev/null; then
        tasks[i]=()
        return
      fi
    done
    sleep 0.1
  done
}

__output() {
  if [ -t 1 ]; then
    tee >(${=CLIPcmd})
  else
    cat
  fi
}

__input() {
  if (($#)); then
    print -l -- $@
  else
    if [ -t 0 ]; then
      ${=PASTEcmd}
      echo
    else
      cat
    fi
  fi
}

__begin_lg() {
  mkdir -p $ZSHDL_STATE_DIR || err Logging "Could not initialize logging directory $ZSHDL_STATE_DIR/.temp"
  sqlite3 $ZSHDL_DB "CREATE TABLE IF NOT EXISTS log (id INTEGER PRIMARY KEY, target TEXT, LS INTEGER, msg TEXT, dest TEXT);"

  ((VERBOSE>2)) && print -u2 "sqlite logging database: $ZSHDL_DB"


  _fields=(target msg dest)
  
  while IFS=$'\0' read -r LS $_fields; do
    [[ $LS == [0-9] ]] || {
       err "Logging" "Empty LS"
      continue
    }
    if [[ -n $target ]]; then
      target="'$(sed "s/'//g" <<< $target)'"
    else
      err "Logging" "Empty target"
      continue
    fi
    if [[ -n $msg ]]; then
      msg="'$(sed "s/'//g" <<< $msg)'"
    else
      msg=NULL
    fi
    if [[ -n $dest ]]; then
      dest="'$(sed "s/'//g" <<< $dest)'"
    else
      dest=NULL
    fi

    sql_query="INSERT INTO log (target, LS, msg, dest) VALUES ($target, $LS, $msg, $dest);"
    sqlite3 "$ZSHDL_DB" $sql_query
  done < $1

  __finish_lg
}

_log_msg() {
  echo $LS$'\0'$LINE$'\0'$1$'\0' >&$lg
}

_log_dest() {
  if [[ -e $1 ]]; then
    echo $LS$'\0'$LINE$'\0'$'\0'$1 >&$lg
  else
    err Nonexistant "$1"
  fi
}

__finish_lg() {
  :
}

### CONFIG

__assert_config_exists() {
  for f in $@; do
    [[ -e $f ]] 
  done
}

__read_config() {
  if [[ -z $CONFIG ]]; then
    [[ -e $ZSHDL_CONFIG_DIR/default.ini ]] &&
    CONFIG=$ZSHDL_CONFIG_DIR/default.ini ||
    warn ConfigNotFound "No .ini config specified."
  fi

  files=($ZSHDL_CONFIG_DIR/handlers.zsh $ZSHDL_CONFIG_DIR/postprocessors.zsh)
  for f in $files; do
    [[ -e $f ]] && source $f || warn ConfigNotFound "$f not found, skipping."
  done

  if [[ -e $CONFIG ]] && offenders=$(__check_config); then
    dbg "Reading config from $CONFIG"

    for proto in $PROTOCOLS; do
      typeset -A _${proto}_HANDLERS
    done

    while IFS='=' read -r key val; do
      [[ ${key%%\#*} == ([[:space:]]##|) ]] && continue
      [[ -z $val ]] && warn EmptyKeyFound "$key" && continue
      case $key in
        ZSHDL_CONNECT_TIMEOUT|ZSHDL_THREADS|ZSHDL_PP_THREADS|VERBOSE|ZSHDL_FORCE_PROTO|ZSHDL_OUTPUT_DIR|ZSHDL_LOG_DISPLAY_LIMIT)
          : ${(P)key:=$val}

          ;;
        http(|s).*)
          method=${val##*\# : }
          # postprocessor decoration found
          if [[ $method != $val ]]; then
            dbg "Registered postprocessing method ($method) for $key"
          fi
          eval "val=$val"
          _HTTP_HANDLERS["$key":$method]=$val
          ;;
        ssh.*|sftp.*)
          method=${val##*\# : }
          # postprocessor decoration found
          if [[ $method != $val ]]; then
            dbg "Registered postprocessing method ($method) for $key"
          fi
          eval "val=$val"
          _SSH_HANDLERS["$key":$method]=$val
          ;;
        file.*)
          method=${val##*\# : }
          # postprocessor decoration found
          if [[ $method != $val ]]; then
            dbg "Registered postprocessing method ($method) for $key"
          fi
          eval "val=$val"
          _FILE_HANDLERS["$key":$method]=$val
          ;;
        na.*)
          method=${val##*\# : }
          # postprocessor decoration found
          if [[ $method != $val ]]; then
            dbg "Registered postprocessing method ($method) for $key"
          fi
          eval "val=$val"
          _NA_HANDLERS["$key":$method]=$val
          ;;
      esac
    done < $CONFIG

    for proto in $PROTOCOLS; do
      protodict=_"$proto"_HANDLERS
      export "$proto"_HANDLERS="$(for k v in "${(@Pkv)protodict}"; do echo "$k=$v"; done; echo "$proto:l".default=\*)"
    done

  else
    err "InvalidConfig" "Errors found in $offenders[*]."
    exit 1
  fi
}

__check_config() {
  :
}

__edit_config() {
  local i file files
  i=1

  files=($ZSHDL_CONFIG_DIR/*.ini(N) $ZSHDL_CONFIG_DIR/handlers.zsh(N) $ZSHDL_CONFIG_DIR/postprocessors.zsh(N))
  for file in ${files[@]}; do
    echo "$i) $file"
    ((i++))
  done
  print -n "Enter a number to edit: "
  read -r i
  [[ -n $files[i] ]] || exit 1
  ${CONFIG_EDITOR:-${VISUAL:-${EDITOR:-nano}}} $files[i]
  __check_config
  exit $?
}

_display_api() {
  api=(http.default ssh.default file.default)
  api+=(_get_dest _success_or_log)
  for f in $api; do
    which $f
  done
}

### BEGIN
usage() {
    cat <<EOF
Usage: $PROG [-hi] [...paths]

Dead simple cli declarative download tool.

Options:
  -c [name]:  Use name.ini in $ZSHDL_CONFIG_DIR as the config
  -h:         Display this help message and exit


Examples:
  dl
    Parses clipboard for urls to download
  dl "https://gutenberg.org/ebooks/76257" "https://github.com/sumoduduk/terminusdm/tree/main/src"
    Download book #76257 as a markdown file, and the src/ folder of the sumoduduk/terminusdm in the main branch to the current directory
  dl -i media < urls.txt
    Download supported media from urls
EOF

  (($#)) && exit $1
}

EDIT=false
SHOWLOG=false
SCRIPT="$(readlink -f -- "$0")"
PROG="$(basename "$0")"
while getopts "hsevc:" opt; do
    case "$opt" in
        c)
            CONFIG=$ZSHDL_CONFIG_DIR/$OPTARG.ini
            ;;
        e)
            EDIT=true
            ;;  
        v)
            VERBOSE=2
            ;;
        h)
            ((VERBOSE>1)) && _display_api
            usage 0
            ;;
        s)
            SHOWLOG=true
            ;;
        *)
            usage 1
            ;;
    esac
done
shift $((OPTIND - 1))

__read_config $CONFIG
$SHOWLOG && __show_log && exit
$EDIT && __edit_config $CONFIG

# Begin
LG=$(mktarget -arpv0 dl_lg)
__begin_lg $LG &
LG_ID=$!
exec {lg}> $LG

PP=$(mktarget -arpv0 dl_pp)
__begin_pp $PP | __output &
PP_ID=$!
exec {pp}> $PP

tasks=()
__input $@ | while read -r line && [[ -n $line ]]; do
  (($#tasks >= $ZSHDL_THREADS)) && __wait_any
  handle $line | __output &
  tasks+=$!
done

exec {pp}>&-
exec {lg}>&-
rm $LG $PP
wait $PP_ID
wait $LG_ID