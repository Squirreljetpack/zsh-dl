#!/bin/zsh

setopt extended_glob
setopt local_options

### HANDLERS
handle_pretransform() {
  proto=${1%%://*}
  stem=${1#*://}
  if [[ -n $ZSHDL_FORCE_PROTO ]]; then
    proto=$ZSHDL_FORCE_PROTO
  elif [[ $proto == $stem ]]; then
    proto=
  fi
  echo $proto
  echo $stem
}

# entrypoint
handle() {
  export LS=-3
  export TARGET=$1
  [[ -n $TARGET ]] || return
  handle_pretransform $1 | {
    read -r proto
    read -r stem
  }

  ((VERBOSE>1)) && info proto

  handle=handle_$proto
  if is_function $handle; then
    $handle $stem
  else
    handle_na $TARGET
  fi
}


handle_http() {
  url=$1
  if [[ $url == *"?"* ]]; then
    params=${url#*"?"}
    url=${url%%"?"*}
  fi
  shift 1

  info url
  [[ -n $params ]] && info params


  while IFS='=' read -r _handler pattern; do
    patterns=(${(s.:.)pattern})
    if [[ $url == $~patterns[1] ]] && 
    [[ (($#patterns < 2)) || $params == $~patterns[2] ]]; then
      LS=-3
      handler=${_handler%(\||:)*}
      _method=${_handler#$handler}
      seperator=${_method:0:1}
      method=${_method:1}
      (( VERBOSE > 1 )) && info handler method
      is_function $handler || internal_err
      dest="$($handler $url $params)" &&
      __submit_pp $dest $method
      [[ $seperator == : ]] && return
    fi
  done <<< $HTTP_HANDLERS

  internal_err
}

handle_https() {
  handle_http $@
}

handle_ssh() {
  target=$1
  subpath=${${1#*:}%.git}
  userhost=${1%%:*}
  shift 1

  info target userhost subpath

  while IFS='=' read -r _handler pattern; do
    patterns=(${(s.:.)pattern})
    if [[ $target == $~patterns[1] ]] && 
    [[ (($#patterns < 2)) || $userhost == $~patterns[2] ]] &&
    [[ (($#patterns < 3)) || $subpath == $~patterns[3] ]]; then
      LS=-3
      handler=${_handler%(\||:)*}
      _method=${_handler#$handler}
      seperator=${_method:0:1}
      method=${_method:1}
      (( VERBOSE > 1 )) && info handler method
      is_function $handler || internal_err
      dest="$($handler $userhost $subpath)" &&
      __submit_pp $dest $method
      [[ $seperator == : ]] && return
    fi
  done <<< $SSH_HANDLERS

  internal_err
}

handle_sftp() {
  handle_ssh $@
}

handle_file() {
  target=$1

  if [[ ! -e $target && ! -L $target ]]; then
     internal_err "Nonexistant" $target
     return 1
  fi

	type=$(get_file_type $target)
  res="$(file -b --mime $target)"
	mime=${res%%\; *}
	encoding=${res#*\; }
  shift 1

  info target type mime encoding
	
  while IFS='=' read -r _handler pattern; do
	  patterns=(${(s.:.)pattern})
    if [[ $target == $~patterns[1] ]] && 
    [[ (($#patterns < 2)) || $type == $~patterns[2] ]] &&
    [[ (($#patterns < 3)) || $mime == $~patterns[3] ]] &&
    [[ (($#patterns < 4)) || $encoding == $~patterns[4] ]]; then
      LS=-3
      handler=${_handler%(\||:)*}
      _method=${_handler#$handler}
      seperator=${_method:0:1}
      method=${_method:1}
      (( VERBOSE > 1 )) && info handler method
      is_function $handler || internal_err
      dest="$($handler $target $type $mime $encoding)" &&
      __submit_pp $dest $method
      [[ $seperator == : ]] && return
    fi
	done <<< $FILE_HANDLERS

  internal_err
}

handle_na() {
  target=$1
  shift 1

  if [[ -e $target ]]; then
    handle_file $target
    return
  elif [[ $target =~ '^[a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+:.+$' ]]; then
    handle_ssh $target
    return
  else
    while IFS='=' read -r _handler pattern; do
      if [[ $target == $~pattern ]]; then
        [[ $_handler != na.default ]] && LS=-3
        handler=${_handler%(\||:)*}
        _method=${_handler#$handler}
        seperator=${_method:0:1}
        method=${_method:1}
        (( VERBOSE > 1 )) && info handler method
        is_function $handler || internal_err
        dest="$($handler $target)" &&
        __submit_pp $dest $method
      [[ $seperator == : ]] && return
      fi
    done <<< $NA_HANDLERS
  fi
  
  internal_err
}

# empty proto_handler for user to use if they want to force some handler methods
handle_misc() {
  target=$1
  shift 1

  while IFS='=' read -r _handler pattern; do
    if [[ $target == $~pattern ]]; then
      [[ $_handler != na.default ]] && LS=-3
      handler=${_handler%(\||:)*}
      _method=${_handler#$handler}
      seperator=${_method:0:1}
      method=${_method:1}
      (( VERBOSE > 1 )) && info handler method
      is_function $handler || internal_err
      dest="$($handler $target)" &&
      __submit_pp $dest $method
      [[ $seperator == : ]] && return
    fi
  done <<< $MISC_HANDLERS
  
  internal_err
}

#### API

# Note on naming: Overrideable functions are named normally, "public" helper functions intended to be called are prefixed with an underscore, and __functions are internal.

## Handler Defaults
http.default() {
  : args: url query
  : output: successfully created files, one per line
  :
  target=$1
  read_dest http $target || return 0
  [[ $target != http(|s)://* ]] && target="https://$target"
  [[ -n $2 ]] && target+="?$2"
  shift 1
  
  case $dest in
    *)
      opts=()
      if [[ -e $dest ]] && curl -I $target | grep -qi accept-ranges; then
        opts+=(-C - -O) # continue at end, original filename
      else
        opts+=(-o $dest)
      fi
      
      success_or_log curl -fL $opts $target || return
      ;;
  esac
  
  echo $dest
}

ssh.default() {
  : args: user@host subpath
  : output: successfully created files, one per line
  :
  read_dest ssh $2  || return 0
  success_or_log rsync -e "ssh -o ConnectTimeout=$ZSHDL_CONNECT_TIMEOUT" -avucz --partial $1:$2 $dest:h || return 1 # -u does an update in case we decided to keep the target, :t is due to rsync always copies into directories
  echo $dest
}

file.default() {
  : args: target type mime encoding
  : output: successfully created files, one per line
  :
  echo $1
}

na.default() {
  warn Unhandled "\"$1\""
  _log_skipped
  return 1
}

http.na() {
  :
}

ssh.na() {
  :
}

file.na() {
  :
}

na.na() {
  :
}

## Getters

read_dest() {
  : arg: protocol '<a path-like string>' '[...pere_args]'
  : output: 'stores <a valid destination for $2> into the variable dest, otherwise returns 1 and outputs "# " (logs the task as skipped)'
  : notes: 'Prompts the user in case of conflict. Ex.' 'read_dest file $1:r.md -a && echo $dest || return 0'
  :
  proto=$1
  shift 1
  case $proto in
    http(|s))
      _dest=${${1%/\#[^\#/]##}:t} # strip #id
      [[ -z $dest:e ]] && _dest+=.html
      ;;
    ssh)
      subpath=${1%.git}
      _dest=$subpath:t
      ;;
    (|s)ftp)
      _dest=$1:t
      ;;
    file)
      _dest=$1:t
      ;;
    *)
      false
    ;;
  esac
  dest="$(pere -d ${@:2} $ZSHDL_OUTPUT_DIR$_dest)" || {
    echo "# $_dest"
    return 1
  }
}

get_html_field() {
  sed -n 's:.*<$field>\(.*\)</$field>.*:\1:p' $1 | tr -cd '[a-zA-Z0-9 -_[]()]'
}

get_file_type() {
  # provides a char from fdsbcxesp for file, directory, symlink, block-device, char-device, executable, empty, socket, pipe
  if [[ -L $1 ]]; then
    echo "l"
  elif [[ -d $1 ]]; then
    echo "d"
  elif [[ -b $1 ]]; then
    echo "b"
  elif [[ -c $1 ]]; then
    echo "c"
  elif [[ -S $1 ]]; then
    echo "s"
  elif [[ -p $1 ]]; then
    echo "p"
  elif [[ -f $1 ]]; then
    if [[ ! -s $1 ]]; then
      echo "e"
    elif [[ -x $1 ]]; then
      echo "x"
    else
      echo "f"
    fi
  else
    echo "u"
  fi
}

get_real() {
  proto=$1
  shift 1
  case $proto in
    http(|s))
      curl --silent --output /dev/null --location --write-out '%{url_effective}' $1
      ;;
    file)
      echo $1:P
      ;;
    *)
      echo $1
    ;;
  esac
}

## Utils

internal_err() {
  print -u2 "[InternalError]" "${(j. .)@}"
  return 1
}

fatal_err() {
  print -u2 "[FatalError]" "${(j. .)@}"
  exit 1
}

err() {
  # todo make error red
  print -u2 -- "[ERROR: $1] $2"
  [[ -n $TARGET ]] && _log_msg "[ERROR: $1] $2"
  return 1
}

warn() {
  # make orange
  ((VERBOSE)) || return
  print -u2 -- "[WARN: $1] $2"
}

info() {
  ((VERBOSE)) || return
  # make info blue
  while (($#)); do
    print -u2 -- "[INFO: $1] ${(P)1}"
    [[ -n $TARGET ]] && ((VERBOSE>1)) && _log_msg "[INFO: $1] ${(P)1}"
    shift 1
  done
}

dbg() {
  ((VERBOSE>1)) && print -u2 -- "[DEBUG] $1"
}

dbginfo() {
  ((VERBOSE>1)) || return
  # make info blue
  while (($#)); do
    print -u2 -- "[INFO: $1] ${(P)1}"
    shift 1
  done
}

is_function() {
  (($# == 1)) || return 1
  [[ -n ${functions[$1]} ]]
}

success_or_log() {
  : args: command_to_run args_to_cmd
  : runs input as a command, and logs stdin+stdout if failed
  : use "success_or_log ..cmd || return" on log failures on critical steps
  :
  result="$($@ 2> >(tee /dev/fd/2))"
  code=$?
  if ((code)); then
    LS=$code TAG=${TAG:-$1} _log_msg $result # TAG not implemented
    return $code
  fi
}

failure_or_show() {
  : args: command_to_run args_to_cmd
  : outputs stdin on sucess, logs stderr on failure
  : use "failure_or_show" on the final step if it is failable
  :
  err_tf="$(mktemp)"
  trap 'rm $err_tf' EXIT
  output=$($@ 2> >(tee $err_tf >&2))
  code=$?
  if ((code)); then
    err_msg="$(< $err_tf)"
    LS=$code err ${funcstack[2]} $err_msg
    return 1
  else
    echo $output
    return
  fi

}

## Log rendering utils

# Strips ANSI codes to get the real string length
__get_visible_length() {
  local str_no_ansi
  str_no_ansi=${(S)1//(#m)\x1b\[[0-9;]*m/}
  print -n ${#str_no_ansi}
}

# Centers text within a given width
__center_text() {
  local text=$1
  local width=$2
  local len
  len=$(__get_visible_length $text)
  local pad_len=$(( (width - len) / 2 ))
  local remainder=$(( (width - len) % 2 ))
  printf "%*s%s%*s" $((pad_len+ remainder)) "" $text $pad_len ""
}

__truncate_right() {
  local text=$1
  local width=$2
  if (( $(__get_visible_length $text) > width )); then
    print -n -- "${text:0:$((width-1))}…"
  else
    printf "%-*s" $width $text
  fi
}

__truncate_left() {
  local text=$1
  local width=$2
  if (( $(__get_visible_length $text) > width )); then
    print -n -- "…${text:$(($#text-width+1))}"
  else
    printf "%*s" $width $text
  fi
}



RESET_COLOR=$'\033[0m'
_get_LS_color() {
  case $1 in
    -2) print -n '\033[90m' ;;      # Muted Grey (for Skipped)
    -1) print -n   '\033[34m' ;;      # Blue (for partial success)
    0) print -n '\033[32m' ;;      # Green (for total success)
    -*) print -n '\033[37m' ;;      # White (for misc?)
    *) print -n '\033[31m' ;;    # Bright Red (for Errors)
    # 2) print -n '\033[38;5;203m' ;; # Salmon
  esac
}
__show_log_entries() {
  if [[ ! -f $ZSHDL_DB ]]; then
    internal_err show_log_entries "Database not found: $ZSHDL_DB"
    return 1
  fi

  if [[ $# -eq 0 ]]; then
    warn show_log_entries "No log IDs provided."
    return 0
  fi

  local first_entry=true

  local log_id log_ls log_target log_msg log_dir log_time

  base_select="SELECT id, strftime('%m-%d %H:%M:%S', time, 'localtime'), target, COALESCE(msg, ' '), COALESCE(dest, ' '), COALESCE(directory, ' '), LS FROM \"$ZSHDL_VARIANT\""
  query=""

  if [[ "$1" =~ ^([0-9]+):$ ]]; then
    query="SELECT * FROM ($base_select ORDER BY id DESC LIMIT ${1%:}) sub ORDER BY sub.id ASC;"

  elif [[ "$1" == ":" ]]; then
    query="$base_select ORDER BY id ASC;"

  else
    ids_list="${${(j.,.)@}%,}"
    query="$base_select WHERE id IN ($ids_list);"
  fi
  first_entry=true
  stty -icanon -ixon
  sqlite3 -separator $'\t' "$ZSHDL_DB" "$query" |
  while IFS=$'\t' read -r log_id log_time log_target log_msg log_dest log_dir log_ls; do
    $first_entry && print && first_entry=false
    local header_pre="Task $log_id:   status code "
    local header_text="$header_pre$(_get_LS_color $log_ls)$log_ls$RESET_COLOR"
    local header_text_nocolor="$header_pre$log_ls"
    local width=${#header_text_nocolor}

    local line=""
    for (( i=0; i < width; i++ )); do line+="─"; done

    print "  ┌─${line}─┐"
    printf "  │ %s │\n" "$header_text"
    print "  └─${line}─┘"

    print "  Target: $log_target"

    if [[ -n "$log_dir" ]]; then
      print "    Path: $log_dir"
    fi

    if [[ -n "$log_time" ]]; then
      print "    Time: $log_time"
    fi

    print
    print "  Message:"
    if [[ -n "$log_msg" ]]; then
      print -r -- "${log_msg}" | sed 's/^/    /'
    else
      print "    (No message)"
    fi

  done
}


__show_log() {
  if [[ ! -f $ZSHDL_DB ]]; then
    internal_err show_log "Database not found: $ZSHDL_DB"
    return 1
  fi
  local data
  data=$(sqlite3 "$ZSHDL_DB" -separator $'\t' \
    "SELECT id, strftime('%m-%d %H:%M:%S', time, 'localtime'), target, COALESCE(msg, ' '), COALESCE(dest, ' '), LS
     FROM \"$ZSHDL_VARIANT\"
     ORDER BY id DESC
     LIMIT $ZSHDL_LOG_DISPLAY_LIMIT")

  if [[ -z $data ]]; then
    warn show_log "No log entries found"
    return 0
  fi

  data=${data//$'\t'http(|s):\/\/(www.|)/$'\t'} # todo
  data=${data//$'\t'$HOME/$'\t'\~}

  local headers=$'ID\tTime\tTarget\tMessage\tDestination\tSt'
  local all_data=${headers}$'\n'${data}

  local -a col_widths
  col_widths=($(awk -F'\t' '
  {
    for(i=1; i<=NF; i++) {
      gsub(/\x1b\[[0-9;]*m/, "", $i)
      len = length($i)
      if (len > max[i]) max[i] = len
    }
  }
  END {
    w1 = max[1]; printf "%d ", w1;                                    # ID (exact width)
    w2 = 14; printf "%d ", w2;                      # Time
    w3 = (max[3]<10)?10:max[3]; w3 = (w3>40)?40:w3; printf "%d ", w3; # Target
    w4 = (max[4]<10)?10:max[4]; w4 = (w4>40)?40:w4; printf "%d ", w4; # Message
    w5 = (max[5]<20)?20:max[5]; w5 = (w5>60)?60:w5; printf "%d ", w5; # Destination
    w6 = 2; printf "%d ", w6;                        
  }' <<< "$all_data"))

  # Build and Print Table
  local top_border=┌
  local sep_border=├
  local bot_border=└


  for (( i=1; i <= ${#col_widths}; i++ )); do
    local w="${col_widths[i]}"
    local line="$(repeat $((w + 2)); do printf "%s" '─'; done)"

    top_border+="$line"
    sep_border+="$line"
    bot_border+="$line"

    if (( i < ${#col_widths} )); then
      top_border+="┬"
      sep_border+="┼"
      bot_border+="┴"
    else
      top_border+="┐"
      sep_border+="┤"
      bot_border+="┘"
    fi
  done

  print "Displaying logs for the $ZSHDL_VARIANT config:"
  print "$top_border"
  printf "│ %s │ %s │ %s │ %s │ %s │ %s │\n" \
    "$(__center_text 'ID' "${col_widths[1]}")" \
    "$(__center_text 'Time' "${col_widths[2]}")" \
    "$(__center_text 'Target' "${col_widths[3]}")" \
    "$(__center_text 'Message' "${col_widths[4]}")" \
    "$(__center_text 'Destination' "${col_widths[5]}")" \
    "$(__center_text 'St' "${col_widths[6]}")"
  print "$sep_border"

  # 5. MODIFIED: Read and print 6 columns of data per row.
  while IFS=$'\t' read -r id time target msg dest ls; do
    local color="$(_get_LS_color "$ls")"
    local id_str="$(__center_text "$id" "${col_widths[1]}")"
    local time_str="$(__truncate_right "$time" "${col_widths[2]}")"
    local target_str="$(__truncate_right "$target" "${col_widths[3]}")"
    local msg_str="$(__truncate_right "$msg" "${col_widths[4]}")"
    local dest_str="$(__truncate_left "$dest" "${col_widths[5]}")"
    local ls_str="$(__center_text "$ls" "${col_widths[6]}")"

    printf "│ %s │ %s │ %s │ %s │ %s │ %s%s%s │\n" \
      "$id_str" \
      "$time_str" \
      "$target_str" \
      "$msg_str" \
      "$dest_str" \
      "$color" "$ls_str" "$RESET_COLOR"
  done <<< "$data"

  print "$bot_border"
}

#### POSTPROCESSORS

# entrypoint
__begin_pp() {
  tasks=()
  export INPUT
  export TARGET
  while IFS=$'\0' read -r INPUT _method TARGET; do
    [[ -z $pp ]] && 
    method=${_method%%:*}
    [[ $method != $_method ]] && rest=${_method#$method:} || rest=

    if is_function pp_$method; then
      (($#tasks >= $ZSHDL_PP_THREADS)) && __wait_any

      dbg "Invoked (Method: $method) for (Input: $INPUT)"
      {
        if dest="$(pp_$method $INPUT)"; then
          exec {pp} > $1
          __submit_pp $dest $rest
          exec {pp}>&-
        fi
      } &
    else
      internal_err InvalidPostprocessingMethod "(Method: $method) for (Input: $INPUT)"
    fi &
    tasks+=$!
  done < $1
}

__submit_pp() {
  # Args: dest (created filename) [method]

  while IFS= read -r dest; do
    # End processing and output when there remain no more methods
    if [[ -z $2 ]]; then
      [[ -n $dest ]] && echo $dest
    else
      # Continue processing if not marked as skipped
      if [[ $dest != "# "* && -n $dest ]]; then
          [[ $dest == *$'\0'* ]] &&
          err InvalidName "Files cannot contain null characters ($dest)" ||
          echo $dest$'\0'$2$'\0'$TARGET >&$pp
      fi
    fi

    _log_dest $dest $2
  done <<< ${1:-$'\n'}
}



### BEGIN LOGIC

__wait_any() {
  while true; do
    for (( i=1; i<=$#tasks; i++ )); do;
      if ! kill -0 $tasks[i] 2>/dev/null; then
        tasks[i]=()
        return
      fi
    done
    sleep 0.1
  done
}

__output() {
  if [ -t 1 ]; then
    tee >&$cb
  else
    cat
  fi
}

__input() {
  if (($RETRY_FROM)); then
    __lg_get_since_failed $RETRY_FROM
    # todo: reprocess
    return
  fi

  # todo: try cycling for input in the future
  if (($#)); then
      print -rl -- $@
    else
      if $STDIN; then
        echo "$(${=PASTEcmd})" # buffer
      else
        cat
    fi
  fi | __lg_filter_skipped
}

__mkpipe() {
  q="$(mktemp -u /tmp/$1.XXX)"
  mkfifo $q >/dev/null || fatal_err "Could not create pipe"
  echo $q
}


__lg_get_since() {
  (($#>2)) || return
  local field=$1
  local id=$2
  shift 2
  local in_clause="${(j:,:)@}"

  local query="
    SELECT $field FROM \"$ZSHDL_VARIANT\"
    WHERE id > $id AND LS IN ($in_clause);
  "

  sqlite3 "$ZSHDL_DB" "$query"
}

__lg_get_since_failed() {
  local query="
    SELECT DISTINCT target FROM \"$ZSHDL_VARIANT\"
    WHERE id > $1 AND LS > 0;
  "

  sqlite3 "$ZSHDL_DB" "$query"
}


__lg_filter_skipped() {
  if $ZSHDL_SKIP; then
    lines="$(sqlite3 "$ZSHDL_DB" "SELECT DISTINCT target FROM \"$ZSHDL_VARIANT\" WHERE LS = 0")"
    lines=(${(@f)lines})
    while IFS= read -r line; do
      if ((${lines[(Ie)$line]})); then
        TARGET=$line _log_skipped
      else
        echo $line
      fi
    done
  else
    cat
  fi
}

__clear_logs() {
  if [[ ! -f $ZSHDL_DB ]]; then
    internal_err show_log_entries "Database not found: $ZSHDL_DB"
    return 1
  fi
  printf "This will clear all logs. Are you sure? [y/n]: "
  read -r ans
  [[ $ans == [Yy]* ]] && rm -f $ZSHDL_DB &&
  echo "Logs deleted." || return 1
}

__begin_lg() {
  if $ZSHDL_NOLOG; then cat $1 > /dev/null; return; fi
  mkdir -p $ZSHDL_STATE_DIR || fatal_err Logging "Could not initialize logging directory $ZSHDL_STATE_DIR/.temp"
  sqlite3 $ZSHDL_DB "CREATE TABLE IF NOT EXISTS \"$ZSHDL_VARIANT\" (id INTEGER PRIMARY KEY, time DATETIME DEFAULT CURRENT_TIMESTAMP, directory TEXT, target TEXT, LS INTEGER, msg TEXT, dest TEXT, input TEXT);"

  dbg "sqlite logging database: $ZSHDL_DB"


  _fields=(target _msg _dest input)

  while IFS=$'\0' read -r LS $_fields; do
    [[ -z $LS ]] && continue

    [[ $LS == (-|)[0-5] ]] || {
      dbg "[Logging: Invalid LS] $LS"
      continue
    }

    if [[ -n $target ]]; then
      target="'${target//\'/\'\'}'"
    else
      dbg "Logging: Empty target"
      continue
    fi

    if [[ -n $input ]]; then
      _input="'${input//\'/\'\'}'"
    else
      _input=NULL
    fi

    if [[ -n $_msg ]]; then
      msg="'${_msg//\'/}'"
      _msg="'$(sed "s/'//g" <<< $_msg)'"
    else
      _msg=NULL
    fi

    _dest=${_dest#"# "}
    if [[ -n $_dest ]]; then
      if [[ $PWD == *\'* || $_dest ==  *\'* ]]; then
        err Logging "Destination or Directory contains invalid characters, skipping log."
        continue
      fi

      _dest="'${_dest}'"
      _directory="'${PWD}'"
    else
      _dest=NULL
      _directory=NULL
    fi

    dbginfo target LS _directory _msg _dest

    sql_query="INSERT INTO \"$ZSHDL_VARIANT\" (target, LS, directory, msg, dest, input) VALUES ($target, $LS, $_directory, $_msg, $_dest, $_input);"

    sqlite3 "$ZSHDL_DB" $sql_query
  done < $1

  __finish_lg
}

_log_msg() {
  [[ -z $LS || -z $TARGET || -z $1 ]] && return 1

  msg=${${1%%$'\n'##}//$'\n'/' \\\\ '}
    # print -u2 "Error: missing one of LS: $LS, LINE: $TARGET, MSG: $1" ||
  print -r -- $LS$'\0'$TARGET$'\0'$1$'\0'"# "$'\0'$INPUT >&$lg
}

_log_skipped() {
  # args: dest method
  $ZSHDL_EXPLICITSKIP && [[ -z $1 ]] && return
  ((VERBOSE)) && print -u2 -- "[Skipped] ${1:-${INPUT:-${TARGET}}}"

  if [[ -n $2 ]]; then
    method="-> $2"
  else
    method=
  fi

  print -r -- -2$'\0'$TARGET$'\0'$method$'\0'"${1:-"# "}"$'\0'$INPUT >&$lg # second last field cannot be empty
}

_log_dest() {
  # args: dest method (can be empty)
  # outputs: none
  if [[ -z $1 || $1 == '# '* ]]; then
    _log_skipped $@
    return
  fi

  dest=${1/#$HOME/~}
  if [[ -z $INPUT ]]; then
    print -u2 -- "[Downloaded] $dest"
  else
    print -u2 -- "[Processed] $dest"
  fi

  if [[ -n $2 ]]; then
    LS=-1
    method="-> $2"
  else
    method=
    LS=0
  fi

  print -r --  $LS$'\0'$TARGET$'\0'$method$'\0'"$dest"$'\0'$INPUT >&$lg
}

__finish_lg() {
  :
}

### CONFIG

__assert_config_exists() {
  for f in $@; do
    [[ -e $f ]] 
  done
}

__read_config() {
  [[ ! -d $ZSHDL_CONFIG_DIR ]] && fatal_err "Configuration directory not found (ZSHDL_CONFIG_DIR @ '$ZSHDL_CONFIG_DIR'). Please check your installation."

  if [[ -z $CONFIG ]]; then
    [[ -e $ZSHDL_CONFIG_DIR/default.ini ]] &&
    CONFIG=$ZSHDL_CONFIG_DIR/default.ini ||
    fatal_err "No config found."
  elif (($#CONFIG > 1)); then
    fatal_err "Multiple configs $CONFIG[*] matched."
  fi

  dbg "Reading config from $CONFIG"
  offenders=$(__check_config) && ZSHDL_VARIANT=$CONFIG:r:t || {
    fatal_err "Invalid config"
  }

  typeset -Ug ZSHDL_CONFIG_FILES
  ZSHDL_CONFIG_FILES=($ZSHDL_CONFIG_DIR/handlers.zsh $ZSHDL_CONFIG_DIR/postprocessors.zsh $ZSHDL_CONFIG_DIR/$ZSHDL_VARIANT_*.zsh(N))
  
  for f in $ZSHDL_CONFIG_FILES; do
    [[ -f $f ]] && source $f || warn ConfigNotFound "$f not found, skipping."
  done

  for proto in $PROTOCOLS; do
    export ${proto}_HANDLERS=""
  done

  _CONSTANTS=${(j.|.)CONSTANTS}

  while IFS='=' read -r key val || [[ -n $key ]]; do
    [[ ${key%%\#*} == ([[:space:]]##|) ]] && continue
    [[ -z $val ]] && warn EmptyKeyFound $key && continue
    case $key in
      ${~_CONSTANTS})
        : ${(P)key::=$val}
        ;;
      http(|s).*)
        # postprocessor decoration found
        [[ $key != *(:|\|)* ]] && key+=:
        eval "val=$val"
        HTTP_HANDLERS+="$key=$val"$'\n'

        dbg "Registered $key for $val"
        ;;
      ssh.*|sftp.*)
        [[ $key != *(:|\|)* ]] && key+=:
        eval "val=$val"
        SSH_HANDLERS+="$key=$val"$'\n'

        dbg "Registered $key for $val"
        ;;
      file.*)
        [[ $key != *(:|\|)* ]] && key+=:
        eval "val=$val"
        FILE_HANDLERS+="$key=$val"$'\n'

        dbg "Registered $key for $val"
        ;;
      na.*)
        [[ $key != *(:|\|)* ]] && key+=:
        eval "val=$val"
        NA_HANDLERS+="$key=$val"$'\n'

        dbg "Registered $key for $val"
        ;;
    esac
  done < $CONFIG

  for proto in $PROTOCOLS; do
    protoh="${proto}_HANDLERS"
    : ${(P)protoh::="${(P)protoh}${proto:l}.default:=*"$'\n'}
  done
}

__check_config() {
  if ! [[ $CONFIG:r:t == [a-zA-Z0-9_-]## ]]; then
    internal_err "Config name ($CONFIG:r:t) must be alphanumeric"
    return 1
  fi
  [[ -f $CONFIG ]]
  # err "InvalidConfig" "Errors found in $offenders[*]."
}

__edit_config() {
  local i file files
  i=3

  echo "Editing files for the $ZSHDL_VARIANT config:"

  echo "1) Clear Database"
  echo "2) $CONFIG"
  for file in ${ZSHDL_CONFIG_FILES[@]}; do
    echo "$i) $file"
    ((i++))
  done
  print -n "Enter a number to edit: "
  read -r i



  if [[ $i == 1 ]]; then
    rm $ZSHDL_DB || fatal_err "Could not delete database"
    exit
  elif [[ $i == 2 ]]; then
    file=$CONFIG
  else
    file=${ZSHDL_CONFIG_FILES[$((i-2))]}
  fi

  [[ -n $file ]] || fatal_err InvalidSelection

  ${CONFIG_EDITOR:-${VISUAL:-${EDITOR:-nano}}} $file
  __check_config
  exit $?
}

__display_api() {

  echo "Check $ZSHDL_CONFIG_DIR for how to define your hadnlers and matching rules"

  echo "\n### DEFAULT HANDLERS ###\n"

  api=(http.default ssh.default file.default)
  for f in $api; do
    functions $f
  done

  echo "\n### API ###\n"

  api=(read_dest failure_or_show success_or_log)
  for f in $api; do
    functions $f
  done

  if ((VERBOSE > 2)); then
    api=(info warn err dbg fatal_err have get_file_type get_html_field get_real)
    for f in $api; do
      functions $f
    done

  fi

  echo "\n### CONSTANTS ###\n"

  for c in $CONSTANTS; do
    print -- "$c: ${(P)c}"
  done

  echo "\n### USAGE ###\n"
}

### CONSTANTS

PROTOCOLS=(HTTP SSH FILE NA)

have() {
  (( $+commands[${1%% *}] ))
}

# Bootstrapping function to conveniently enable or gracefully fail features
exportCmdVar() {
  local var_name=$1
  shift
  for param; do
    if have $param; then
      typeset -gx "$var_name=$param"
      return 0
    fi
  done
  typeset -gx "$var_name=false"
  return 1
}

exportCmdVar "CLIPcmd" \
  "xclip -sel clip" \
  "pbcopy"

exportCmdVar "PASTEcmd" \
  "xclip -o" \
  "pbpaste"

exportCmdVar "FORMATPYTHONcmd" \
  "ruff"

exportCmdVar "HTML2MARKDOWNcmd" \
  "html2markdown"

exportCmdVar "YTDLPcmd" \
  "yt-dlp"

exportCmdVar "GALLERYDLcmd" \
  "gallery-dl"

if ! have pere; then
  pere() {
    local file=${@[$#]}
    while  [[ -z $file || -e $file ]]; do
      print -n -u2 "$file exists! Please choose a different name: "
      read -r file </dev/tty || return 1
    done
    
    case $1 in
      -d)    echo $file;;
      -m)    shift 1; mv $@;;
      -c)    shift 1; mv -r $@;;
    esac
  }
fi

unset -f exportCmdVar

CONSTANTS=(ZSHDL_CONNECT_TIMEOUT ZSHDL_THREADS ZSHDL_PP_THREADS VERBOSE ZSHDL_FORCE_PROTO ZSHDL_OUTPUT_DIR ZSHDL_LOG_DISPLAY_LIMIT ZSHDL_STATE_DIR ZSHDL_CONFIG_DIR ZSHDL_SKIP ZSHDL_NOLOG ZSHDL_EXPLICITSKIP ZSHDL_STRIPWHITESPACE)

: ${ZSHDL_CONNECT_TIMEOUT:=5}
: ${ZSHDL_THREADS:=5}
: ${ZSHDL_PP_THREADS:=5}
[[ $VERBOSE == [0-9] ]] || VERBOSE=1
[[ $ZSHDL_SKIP == (true|false) ]] || ZSHDL_SKIP=false
[[ $ZSHDL_EXPLICITSKIP == (true|false) ]] || ZSHDL_EXPLICITSKIP=true
[[ $ZSHDL_NOLOG == (true|false) ]] || ZSHDL_NOLOG=false
[[ $ZSHDL_STRIPWHITESPACE == (true|false) ]] || ZSHDL_STRIPWHITESPACE=false
: ${ZSHDL_FORCE_PROTO}
: ${ZSHDL_OUTPUT_DIR:=./}
: ${ZSHDL_LOG_DISPLAY_LIMIT:=50}

: ${ZSHDL_STATE_DIR:=$HOME/.local/state/zsh-dl}
ZSHDL_DB=$ZSHDL_STATE_DIR/log.db
: ${ZSHDL_CONFIG_DIR:=$HOME/.config/zsh-dl}
### ARGPARSE

usage() {
  ((VERBOSE>1)) && __display_api

  cat <<EOF
Usage: $PROG [-hlesv] [-c name] [-r count] […inputs/…log_ids]

Extensible cli download tool.

Options:
  -c <name>         : Use name.ini in $ZSHDL_CONFIG_DIR as the config.
  -e                : Edit configuration files.
  -h                : Display this help message and exit.
  -l                : Show the log.
                        Providing a list of …log_ids or [n]: for the last n logs will display full execution details.
  --from [log_id=0] : Retry failed downloads.
  -s                : Skip inputs which succeded in the past. ( ZSHDL_SKIP=true|false )
  -v                : Set verbosity 2
  --verbose [level] : Set verbosity level
  --clear [glob]    : Clear logs

Environment variables and configuration:
  See $PROG -v -h

Examples:
  $PROG
    Parses clipboard for urls to download
  $PROG "https://gutenberg.org/ebooks/76257"
    Download book #76257 as a markdown file
  $PROG "https://github.com/sumoduduk/terminusdm/tree/main/src"
    Download the src/ folder of the sumoduduk/terminusdm in the main branch to the current directory
  $PROG "user@host:path/to/your/file.tx"
    Downloads over SSH
  $PROG -ci "google.com"
    Gets info about a URL/file
  $PROG -cf "path/to/your/script.zsh" "random_weather.py"
    Format local files using the fmt.ini config
  $PROG -cm < urls.txt
    Process a list of URLs in a file (media.ini):

Status codes:

   …: Misc/Processing
  -2: Unhandled/Skipped
  -1: Partial Success
   0: Success
  >0: Handling error
EOF
  
  (($#)) && exit $1
}

EDIT=false
SHOWLOG=false
SHOWHELP=false
RETRY_FROM=0
RETRY=1
SCRIPT="$(readlink -f -- "$0")"
PROG="$(basename "$0")"
ZSHDL_VARIANT=default

TARGET=
INPUT=
CLEAR_LOGS=

new_args=()
_posargs=false
while [[ $# -gt 0 ]]; do
  case $1 in
    --help)
      SHOWHELP=true
      ;;
    --from)
      if ! $_posargs; then
        if [[ "$2" =~ ^[0-9]+$ ]]; then
          RETRY_FROM=$2
          shift
        else
          RETRY_FROM=1
        fi
        shift
        continue
      fi
      ;|
    --clear)
      __clear_logs
      exit
      ;;
    --verbose)
      if ! $_posargs; then
        if [[ "$2" =~ ^[0-9]$ ]]; then
          VERBOSE=$2
          shift
        else
          VERBOSE=2
        fi
        shift
        continue
      fi
      ;|
    --)
      _posargs=true
      ;|
    *)
      new_args+=("$1")
      ;;
  esac
  shift
done
set -- "${new_args[@]}"

while getopts "hlevc:r:s" opt; do
    case "$opt" in
        c)
            CONFIG=($ZSHDL_CONFIG_DIR/$OPTARG*.ini)
            ;;
        e)
            EDIT=true
            ;;  
        s)
            ZSHDL_SKIP=true
            ;;
        v)
            VERBOSE=2
            ;;
        h)
            SHOWHELP=true
            ;;
        l)
            SHOWLOG=true
            ;;
        *)
            usage 1
            ;;
    esac
done

$SHOWHELP && usage 0
shift $((OPTIND - 1))


### BEGIN
__read_config $CONFIG

if $SHOWLOG; then
  if (($#)); then
    __show_log_entries $@
  else
    __show_log
  fi
  exit
fi

$EDIT && __edit_config $CONFIG

# Begin
LG="$(__mkpipe dl_lg)"
__begin_lg $LG &
LG_ID=$!
exec {lg}> $LG

CB="$(__mkpipe dl_cb)"
${=CLIPcmd} < $CB &
CB_ID=$!
exec {cb}> $CB

PP="$(__mkpipe dl_pp)"
{ __begin_pp $PP | __output; } &
PP_ID=$!
exec {pp}> $PP

trap "rm $PP $LG" EXIT 

tasks=()


__input $@ | {
$ZSHDL_STRIPWHITESPACE && IFS=
  while read -r line; do
    (( $#tasks >= $ZSHDL_THREADS )) && __wait_any
    { handle $line </dev/tty | __output; } &
    tasks+=$!
  done
}

exec {pp}>&-
exec {lg}>&-
exec {cb}>&-

wait $PP_ID
# wait $LG_ID