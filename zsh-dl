#!/bin/zsh

# https://github.com/sumoduduk/terminusdm

### CONSTANTS

: ${ZSHDL_CONNECT_TIMEOUT:=5}
: ${ZSHDL_THREADS:=5}
: ${ZSHDL_PP_THREADS:=5}
[[ $VERBOSE == [0-9] ]] || VERBOSE=1

: ${ZSHDL_FORCE_PROTO}
: ${ZSHDL_OUTPUT_DIR:=./}
: ${ZSHDL_LOG_DISPLAY_LIMIT:=50}

: ${ZSHDL_STATE_DIR:=$HOME/.local/state/zsh-dl}
ZSHDL_DB=$ZSHDL_STATE_DIR/log.db
: ${ZSHDL_CONFIG_DIR:=$HOME/.config/zsh-dl}

CONSTANTS=(ZSHDL_CONNECT_TIMEOUT ZSHDL_THREADS ZSHDL_PP_THREADS VERBOSE ZSHDL_FORCE_PROTO ZSHDL_OUTPUT_DIR ZSHDL_LOG_DISPLAY_LIMIT ZSHDL_STATE_DIR ZSHDL_CONFIG_DIR)

PROTOCOLS=(HTTP SSH FILE NA)

# (Line Status) LS_CODES
# -2: Unprocessed/Unhandled
# -1: Handling
# 0: HandlerSuccess
# 1: HandlerError
# 2: PPError
# 3: PPSuccess
# 4: InternalError

# Bootstrapping function to conveniently enable or gracefully fail features
exportCmdVar() {
  local var_name=$1
  shift
  for param; do
    if (( $+commands[${param%% *}] )); then
      typeset -gx "$var_name=$param"
      return 0
    fi
  done
  typeset -gx "$var_name=false"
  return 1
}

exportCmdVar "CLIPcmd" \
  "xclip -sel clip" \
  "pbcopy"

exportCmdVar "PASTEcmd" \
  "xclip -o" \
  "pbpaste"

exportCmdVar "FORMATPYTHONcmd" \
  "ruff"

exportCmdVar "HTML2MARKDOWNcmd" \
  "html2markdown"

exportCmdVar "YTDLPcmd" \
  "yt-dlp"

exportCmdVar "GALLERYDLcmd" \
  "gallery-dl"

unset -f exportCmdVar
setopt extended_glob
setopt local_options

### HANDLERS
handle_pretransform() {
  proto=${1%%://*}
  stem=${1#*://}
  if [[ -n $ZSHDL_FORCE_PROTO ]]; then
    proto=$ZSHDL_FORCE_PROTO
  elif [[ $proto == $stem ]]; then
    proto=
  fi
  echo $proto
  echo $stem
}

# entrypoint
handle() {
  export LS=-2
  export LINE=$1
  handle_pretransform $1 | {
    read -r proto
    read -r stem
  }

  ((VERBOSE>1)) && info proto

  handle=handle_$proto
  if is_function $handle; then
    $handle $stem
  else
    handle_na $LINE
  fi
}

internal_err() {
  print -u2 "[InternalError]" "${(j. .)@}"
  return 1
}

fatal_err() {
  print -u2 "[FatalError]" "${(j. .)@}"
  exit 1
}


handle_http() {
  url=$1
  if [[ $url == *"?"* ]]; then
    params=${url#*"?"}
    url=${url%%"?"*}
  fi
  shift 1

  info url
  [[ -n $params ]] && info params


  while IFS='=' read -r _handler pattern; do
    patterns=(${(s.:.)pattern})
    if [[ $url == $~patterns[1] ]] && 
    [[ (($#patterns < 2)) || $params == $~patterns[2] ]]; then
      LS=-1
      handler=${_handler%(\||:)*}
      _method=${_handler#$handler}
      seperator=${_method:0:1}
      method=${_method:1}
      (( VERBOSE > 1 )) && info handler method
      is_function $handler || internal_err
      dest="$($handler $url $params)" &&
      __submit_pp $handler $dest $method
      return
    fi
  done <<< $HTTP_HANDLERS

  internal_err
}

handle_https() {
  handle_http $@
}

handle_ssh() {
  target=$1
  subpath=${${1#*:}%.git}
  userhost=${1%%:*}
  shift 1

  info target userhost subpath

  while IFS='=' read -r _handler pattern; do
    patterns=(${(s.:.)pattern})
    if [[ $target == $~patterns[1] ]] && 
    [[ (($#patterns < 2)) || $userhost == $~patterns[2] ]] &&
    [[ (($#patterns < 3)) || $subpath == $~patterns[3] ]]; then
      LS=-1
      handler=${_handler%(\||:)*}
      _method=${_handler#$handler}
      seperator=${_method:0:1}
      method=${_method:1}
      (( VERBOSE > 1 )) && info handler method
      is_function $handler || internal_err
      dest="$($handler $userhost $subpath)" &&
      __submit_pp $handler $dest $method
      return
    fi
  done <<< $SSH_HANDLERS

  internal_err
}

handle_sftp() {
  handle_ssh $@
}

handle_file() {
  target=$1

  if [[ ! -e $target && ! -L $target ]]; then
     internal_err "Nonexistant" $target
     return 1
  fi

	type=$(get_file_type $target)
  res="$(file -b --mime $target)"
	mime=${res%%\; *}
	encoding=${res#*\; }
  shift 1

  info target type mime encoding
	
  while IFS='=' read -r _handler pattern; do
	  patterns=(${(s.:.)pattern})
    if [[ $target == $~patterns[1] ]] && 
    [[ (($#patterns < 2)) || $type == $~patterns[2] ]] &&
    [[ (($#patterns < 3)) || $mime == $~patterns[3] ]] &&
    [[ (($#patterns < 4)) || $encoding == $~patterns[4] ]]; then
      LS=-1
      handler=${_handler%(\||:)*}
      _method=${_handler#$handler}
      seperator=${_method:0:1}
      method=${_method:1}
      (( VERBOSE > 1 )) && info handler method
      is_function $handler || internal_err
      dest="$($handler $target $type $mime $encoding)" &&
      __submit_pp $handler $dest $method
      return
    fi
	done <<< $FILE_HANDLERS

  internal_err
}

handle_na() {
  target=$1
  shift 1

  if [[ -e $target ]]; then
    handle_file $target
    return
  elif [[ $target =~ '^[a-zA-Z0-9_.-]+@[a-zA-Z0-9_.-]+:.+$' ]]; then
    handle_ssh $target
    return
  else
    while IFS='=' read -r _handler pattern; do
      if [[ $target == $~pattern ]]; then
        [[ $_handler != na.default ]] && LS=-1
        handler=${_handler%(\||:)*}
        _method=${_handler#$handler}
        seperator=${_method:0:1}
        method=${_method:1}
        (( VERBOSE > 1 )) && info handler method
        is_function $handler || internal_err
        dest="$($handler $target)" &&
        __submit_pp $handler $dest $method
        return
      fi
    done <<< $NA_HANDLERS
  fi
  
  internal_err
}

# empty proto_handler for user to use if they want to force some handler methods
handle_misc() {
  target=$1
  shift 1

  while IFS='=' read -r _handler pattern; do
    if [[ $target == $~pattern ]]; then
      [[ $_handler != na.default ]] && LS=-1
      handler=${_handler%(\||:)*}
      _method=${_handler#$handler}
      seperator=${_method:0:1}
      method=${_method:1}
      (( VERBOSE > 1 )) && info handler method
      is_function $handler || internal_err
      dest="$($handler $target)" &&
      __submit_pp $handler $dest $method
      return
    fi
  done <<< $MISC_HANDLERS
  
  internal_err
}

#### API

# Note on naming: Overrideable functions are named normally, "public" helper functions intended to be called are prefixed with an underscore, and __functions are internal.

## Handler Defaults
http.default() {
  target=$1
  dest="$(get_dest http $target)" || return
  [[ $target != http(|s)://* ]] && target="https://$target"
  [[ -n $2 ]] && target+="?$2"
  info dest
  shift 1
  
  case $dest in
    *)
      opts=()
      if [[ -e $dest ]] && curl -I $target | grep -qi accept-ranges; then
        opts+=(-C - -O) # continue at end, original filename
      else
        opts+=(-o $dest)
      fi
      
      success_or_log curl -fL $opts $target || return
      ;;
  esac
  
  echo $dest
}

ssh.default() {
  # Args: user@host, subpath
  dest="$(get_dest ssh $2)"  || return
  success_or_log rsync -e "ssh -o ConnectTimeout=$ZSHDL_CONNECT_TIMEOUT" -avucz --partial $1:$2 $dest:h || return 1 # -u does an update in case we decided to keep the target, :t is due to rsync always copies into directories
  echo $dest
}

file.default() {
  echo $1
}

na.default() {
  warn Unhandled "\"$1\""
  return 1
}

http.na() {
  :
}

ssh.na() {
  :
}

file.na() {
  :
}

na.na() {
  :
}

## Getters

get_dest() {
  proto=$1
  shift 1
  case $proto in
    http(|s))
      dest=${${1%/\#[^\#/]##}:t} # strip #id
      [[ -z $dest:e ]] && dest+=.html
      mktarget -d ${@:2} $ZSHDL_OUTPUT_DIR$dest
      ;;
    ssh)
      subpath=${1%.git}
      dest=$subpath:t
      mktarget -d ${@:2} $ZSHDL_OUTPUT_DIR$dest
      ;;
    (|s)ftp)
      dest=$1:t
      mktarget -d ${@:2} $ZSHDL_OUTPUT_DIR$dest
      ;;
    file)
      dest=$1:t
      mktarget -d ${@:2} $ZSHDL_OUTPUT_DIR$dest
      ;;
    *)
      return 1
    ;;
  esac
}

get_html_field() {
  sed -n 's:.*<$field>\(.*\)</$field>.*:\1:p' $1 | tr -cd '[a-zA-Z0-9 -_[]()]'
}

get_file_type() {
  # provides a char from fdsbcxesp for file, directory, symlink, block-device, char-device, executable, empty, socket, pipe
  if [[ -L $1 ]]; then
    echo "l"
  elif [[ -d $1 ]]; then
    echo "d"
  elif [[ -b $1 ]]; then
    echo "b"
  elif [[ -c $1 ]]; then
    echo "c"
  elif [[ -S $1 ]]; then
    echo "s"
  elif [[ -p $1 ]]; then
    echo "p"
  elif [[ -f $1 ]]; then
    if [[ ! -s $1 ]]; then
      echo "e"
    elif [[ -x $1 ]]; then
      echo "x"
    else
      echo "f"
    fi
  else
    echo "u"
  fi
}

get_real() {
  proto=$1
  shift 1
  case $proto in
    http(|s))
      curl --silent --output /dev/null --location --write-out '%{url_effective}' $1
      ;;
    file)
      echo $1:P
      ;;
    *)
      echo $1
    ;;
  esac
}

## Utils

err() {
  # make error red
  print -u2 -- "[ERROR: $1] $2"
  [[ -n $LINE ]] && _log_msg "[ERROR: $1] $2"
  return 1
}

warn() {
  # make orange
  ((VERBOSE)) || return
  print -u2 -- "[WARN: $1] $2"
}

info() {
  ((VERBOSE)) || return
  # make info blue
  while (($#)); do
    print -u2 -- "[INFO: $1] ${(P)1}"
    ((VERBOSE>1)) && _log_msg "[INFO: $1] ${(P)1}"
    shift 1
  done
}

dbg() {
  ((VERBOSE>1)) && print -u2 -- "[DEBUG] $1"
}

dbginfo() {
  ((VERBOSE>1)) || return
  # make info blue
  while (($#)); do
    print -u2 -- "[INFO: $1] ${(P)1}"
    shift 1
  done
}

is_function() {
  (($# == 1)) || return 1
  [[ -n ${functions[$1]} ]]
}

# use success_or_log ..cmd || return on critical commands
success_or_log() {
  result="$($@ 2> >(tee /dev/fd/2))"
  code=$?
  if ((code)); then
    [[ -n $LS ]] && LS=1 || LS=2 # LS is unset during pp
    TAG=${TAG:-$1} _log_msg $result # TAG not implemented
    return $code
  fi
}

failure_or_show() {
  err_tf=$(mktemp)
  trap 'rm $err_tf' EXIT
  output=$($@ 2> >(tee $err_tf >&2)) && echo $output && return
  [[ -n $LS ]] && LS=1 || LS=2
  err_msg=$(< $err_tf)
  _log_msg "[Err: ${funcstack[2]}] $err_msg"
  return 1
}

## Log rendering utils

# Strips ANSI codes to get the real string length
__get_visible_length() {
  local str_no_ansi
  str_no_ansi=${(S)1//(#m)\x1b\[[0-9;]*m/}
  print -n ${#str_no_ansi}
}

# Centers text within a given width
__center_text() {
  local text=$1
  local width=$2
  local len
  len=$(__get_visible_length $text)
  local pad_len=$(( (width - len) / 2 ))
  local remainder=$(( (width - len) % 2 ))
  printf "%*s%s%*s" $pad_len "" $text $((pad_len + remainder)) ""
}

__truncate_right() {
  local text=$1
  local width=$2
  if (( $(__get_visible_length $text) > width )); then
    print -n -- "${text:0:$((width-1))}…"
  else
    printf "%-*s" $width $text
  fi
}

__truncate_left() {
  local text=$1
  local width=$2
  if (( $(__get_visible_length $text) > width )); then
    print -n -- "…${text:$(($#text-width+1))}"
  else
    printf "%*s" $width $text
  fi
}

_get_LS_color() {
  case $1 in
    -2) print -n '\033[90m' ;;      # Muted Grey (for Unprocessed/Unhandled)
    -1) print -n '\033[37m' ;;      # White (for Handling)
    1|4) print -n '\033[31m' ;;    # Bright Red (for HandlerError & InternalError)
    0) print -n '\033[32m' ;;      # Green (for HandlerSuccess)
    2) print -n '\033[38;5;203m' ;; # Salmon (for PPError)
    3) print -n '\033[34m' ;;      # Blue (for PPSuccess)
    5) print -n '\033[90m' ;;      # Muted Grey (for Skipped)
  esac
}

# todo: add id row, display a log entry like pueue given (a series) of ids, modify cli to do so

__show_log_entry () {
  # query for entries
  for id; do

  done
}
__show_log() {
  if [[ ! -f $ZSHDL_DB ]]; then
    internal_err show_log "Database not found: $ZSHDL_DB"
    return 1
  fi

  local data
  data=$(sqlite3 $ZSHDL_DB -separator $'\t' \
    "SELECT LS, target, COALESCE(msg, ' '), COALESCE(dest, ' ')
     FROM \"$ZSHDL_VARIANT\"
     ORDER BY id DESC
     LIMIT $ZSHDL_LOG_DISPLAY_LIMIT")

  if [[ -z $data ]]; then
    warn show_log "No log entries found"
    return 0
  fi

  data=${data//$'\t'http(|s):\/\/(www.|)/$'\t'}

  local headers=$'St.\tTarget\tMessage\tDestination'
  local all_data=${headers}$'\n'${data}

  local -a col_widths
  col_widths=($(awk -F'\t' '
  {
    for(i=1; i<=NF; i++) {
      gsub(/\x1b\[[0-9;]*m/, "", $i)
      len = length($i)
      if (len > max[i]) max[i] = len
    }
  }
  END {
    w1 = (max[1]<4)?4:max[1]; printf "%d ", w1;
    w2 = (max[2]<10)?10:max[2]; w2 = (w2>40)?40:w2; printf "%d ", w2;
    w3 = (max[3]<10)?10:max[3]; w3 = (w3>40)?40:w3; printf "%d ", w3;
    w4 = (max[4]<20)?20:max[4]; w4 = (w4>60)?60:w4; printf "%d ", w4;
  }' <<< $all_data))

  # Build and Print Table
  local reset_color=$'\033[0m'
  local top_border=+
  local sep_border=+
  local bot_border=+

  for i in $col_widths; do
    local w="$i"
    local line="$(printf "%*s" $((w + 2)) "" | tr ' ' '-')" # strangely, local line on its own produces output!
    top_border+="${line}+"
    sep_border+="${line}+"
    bot_border+="${line}+"
  done


  # Print Header
  print "\nLast $ZSHDL_LOG_DISPLAY_LIMIT Log Entries"
  print $top_border
  printf "| %s | %s | %s | %s |\n" \
    "$(__center_text 'St.' ${col_widths[1]})" \
    "$(__center_text 'Target' ${col_widths[2]})" \
    "$(__center_text 'Message' ${col_widths[3]})" \
    "$(__center_text 'Destination' ${col_widths[4]})"
  print $sep_border

  # Print Data Rows
  while IFS=$'\t' read -r ls target msg dest; do
    local color="$(_get_LS_color $ls)"
    local ls_str="$(__center_text $ls ${col_widths[1]})"
    local target_str="$(__truncate_right $target ${col_widths[2]})"
    local msg_str="$(__truncate_right $msg ${col_widths[3]})"
    local dest_str="$(__truncate_left $dest ${col_widths[4]})"

    printf "| %s%s%s | %s | %s | %s |\n" \
      $color $ls_str $reset_color \
      $target_str  \
      $msg_str \
      $dest_str
  done <<< $data

  print $bot_border
}

#### POSTPROCESSORS

# entrypoint
__begin_pp() {
  tasks=()
  while IFS=$'\0' read -r file method LINE; do
    (($#tasks >= $ZSHDL_PP_THREADS)) && __wait_any
    if [[ -z $method ]]; then
      LS=0
      _log_dest $file
      echo $file
    elif is_function pp_$method; then
      dbg "Invoked (Method: $method) for (File: $file)"
      file=$(pp_$method $file) || return
      LS=3
      _log_dest $file
      echo $file
    else
      internal_err InvalidPostprocessingMethod "(Method: $method) for (File: $file)"
    fi &
    tasks+=$!
  done < $1
}

__submit_pp() {
  # Args: handler dest (created filename) [method]
  LS=0
  if [[ -z $2 ]]; then
    err InvalidName "Empty filename"
    return
  fi

  while read -r dest; do
    _log_dest $dest >/dev/null || continue

    if method=$3 && [[ -n $method ]]; then
      [[ $dest == *$'\0'* ]] &&
        err InvalidName "Files cannot contain null characters ($dest)" &&
        return 1
        
      echo $dest$'\0'$method$'\0'$LINE >&$pp &&
      _log_msg "[PP: $method] invoked for $dest"

    elif method=${1#*.} && [[ -n ${functions[pp_$method]} ]]; then
      [[ $dest == *$'\0'* ]] &&
        err InvalidName "Files cannot contain null characters ($dest)" &&
        return 1
      
      echo $dest$'\0'$method$'\0'$LINE >&$pp &&
      _log_msg "[PP: $method] invoked for $dest"

    else
      echo $dest
    fi
  done <<< "$2"
}



### BEGIN LOGIC

__wait_any() {
  while true; do
    for (( i=1; i<=$#tasks; i++ )); do;
      if ! kill -0 $tasks[i] 2>/dev/null; then
        tasks[i]=()
        return
      fi
    done
    sleep 0.1
  done
}

__output() {
  if [ -t 1 ]; then
    tee >(${=CLIPcmd})& # important!
  else
    cat
  fi
}

__input() {
  if (($#)); then
    print -rl -- $@
  else
    if $STDIN; then
      echo "$(${=PASTEcmd})" # buffer
    else
      cat
    fi
  fi
}

__begin_lg() {
  mkdir -p $ZSHDL_STATE_DIR || internal_err Logging "Could not initialize logging directory $ZSHDL_STATE_DIR/.temp"
  sqlite3 $ZSHDL_DB "CREATE TABLE IF NOT EXISTS \"$ZSHDL_VARIANT\" (id INTEGER PRIMARY KEY, target TEXT, LS INTEGER, msg TEXT, dest TEXT);"

  dbg "sqlite logging database: $ZSHDL_DB"


  _fields=(target msg _dest)

  while IFS=$'\0' read -r LS $_fields; do
    [[ -z $LS ]] && continue

    [[ $LS == (-|)[0-5] ]] || {
      dbg "[Logging: Invalid LS] $LS"
      continue
    }

    if [[ -n $target ]]; then
      target="'${target//\'/}'"
    else
      dbg "Logging: Empty target"
      continue
    fi
    if [[ -n $msg ]]; then
      target="'${msg//\'/}'"
      msg="'$(sed "s/'//g" <<< $msg)'"
    else
      msg=NULL
    fi
    if [[ -n $_dest ]]; then
      _dest="'${_dest//\'/}'"
    else
      _dest=NULL
    fi

    sql_query="INSERT INTO \"$ZSHDL_VARIANT\" (target, LS, msg, dest) VALUES ($target, $LS, $msg, $_dest);"

    sqlite3 "$ZSHDL_DB" $sql_query
  done < $1

  __finish_lg
}

_log_msg() {
  [[ -z $LS || -z $LINE || -z $1 ]] && return 1

  msg=${${1%%$'\n'##}//$'\n'/' \\\\ '}
    # print -u2 "Error: missing one of LS: $LS, LINE: $LINE, MSG: $1" ||
  print -r -- $LS$'\0'$LINE$'\0'$1$'\0' >&$lg
}

_log_dest() {
  local dest
  if [[ $1 == '# '* ]]; then
    local entry=${1#'# '}
    if [[ -e $entry ]]; then
      dest=${entry/#$HOME/~}
      print -u2 -- "[Skipped] $dest"
      print -r -- 5$'\0'$LINE$'\0'$'\0'$dest >&$lg
    else
      err Nonexistant $entry
    fi
    return 5
  fi

  if [[ -e $1 ]]; then
    dest=${entry/#$HOME/~}
    if [[ -z $LS ]] || (( LS == 3 || LS == 2 )); then
      print -u2 -- "[Processed] $dest"
    else
      print -u2 -- "[Downloaded] $dest"
    fi
    print -r --  $LS$'\0'$LINE$'\0'$'\0'$dest >&$lg
  else
    err Nonexistant $1
  fi
}

__finish_lg() {
  :
}

### CONFIG

__assert_config_exists() {
  for f in $@; do
    [[ -e $f ]] 
  done
}

__read_config() {
  [[ ! -d $ZSHDL_CONFIG_DIR ]] && fatal_err "Configuration directory not found (ZSHDL_CONFIG_DIR @ '$ZSHDL_CONFIG_DIR'). Please check your installation."

  if [[ -z $CONFIG ]]; then
    [[ -e $ZSHDL_CONFIG_DIR/default.ini ]] &&
    CONFIG=$ZSHDL_CONFIG_DIR/default.ini ||
    fatal_err "No config found."
  elif (($#CONFIG > 1)); then
    fatal_err "Multiple configs $CONFIG[*] matched."
  fi

  dbg "Reading config from $CONFIG"
  offenders=$(__check_config) && ZSHDL_VARIANT=$CONFIG:r:t || {
    fatal_err "Invalid config"
  }

  typeset -U files
  files=($ZSHDL_CONFIG_DIR/handlers.zsh $ZSHDL_CONFIG_DIR/postprocessors.zsh $ZSHDL_CONFIG_DIR/$ZSHDL_VARIANT_*.zsh(N))
  
  for f in $files; do
    [[ -f $f ]] && source $f || warn ConfigNotFound "$f not found, skipping."
  done

  for proto in $PROTOCOLS; do
    export ${proto}_HANDLERS=""
  done

  while IFS='=' read -r key val; do
    [[ ${key%%\#*} == ([[:space:]]##|) ]] && continue
    [[ -z $val ]] && warn EmptyKeyFound $key && continue
    case $key in
      ZSHDL_CONNECT_TIMEOUT|ZSHDL_THREADS|ZSHDL_PP_THREADS|VERBOSE|ZSHDL_FORCE_PROTO|ZSHDL_OUTPUT_DIR|ZSHDL_LOG_DISPLAY_LIMIT)
        : ${(P)key:=$val}
        ;;
      http(|s).*)
        # postprocessor decoration found
        [[ $key != *(:|\|)* ]] && key+=:
        eval "val=$val"
        HTTP_HANDLERS+="$key=$val"$'\n'

        dbg "Registered $key for $val"
        ;;
      ssh.*|sftp.*)
        [[ $key != *(:|\|)* ]] && key+=:
        eval "val=$val"
        SSH_HANDLERS+="$key=$val"$'\n'

        dbg "Registered $key for $val"
        ;;
      file.*)
        [[ $key != *(:|\|)* ]] && key+=:
        eval "val=$val"
        FILE_HANDLERS+="$key=$val"$'\n'

        dbg "Registered $key for $val"
        ;;
      na.*)
        [[ $key != *(:|\|)* ]] && key+=:
        eval "val=$val"
        NA_HANDLERS+="$key=$val"$'\n'

        dbg "Registered $key for $val"
        ;;
    esac
  done < $CONFIG

  for proto in $PROTOCOLS; do
    protoh="${proto}_HANDLERS"
    : ${(P)protoh::="${(P)protoh}${proto:l}.default:=*"$'\n'}
  done
}

__check_config() {
  if ! [[ $CONFIG:r:t == [a-zA-Z0-9_-]## ]]; then
    internal_err "Config name ($CONFIG:r:t) must be alphanumeric"
    return 1
  fi
  [[ -f $CONFIG ]]
  # err "InvalidConfig" "Errors found in $offenders[*]."
}

__edit_config() {
  local i file files
  i=1

  files=("Clear Database" $ZSHDL_CONFIG_DIR/*.ini(N) $ZSHDL_CONFIG_DIR/*.zsh(N))
  for file in ${files[@]}; do
    echo "$i) $file"
    ((i++))
  done
  print -n "Enter a number to edit: "
  read -r i
  [[ -n $files[i] ]] || exit 1

  if [[ $files[i] == "Clear Database" ]]; then
    rm $ZSHDL_DB || internal_err "Could not delete database"
    exit
  fi

  ${CONFIG_EDITOR:-${VISUAL:-${EDITOR:-nano}}} $files[i]
  __check_config
  exit $?
}

_display_api() {
  api=(http.default ssh.default file.default)
  api+=(get_dest failure_or_show success_or_log)
  for f in $api; do
    which $f
  done

  if ((VERBOSE>2)); then
    echo
    echo "CONSTANTS"
    echo
    for c in $CONSTANTS; do
      print -- "$c: ${(P)c}"
    done
  fi
  echo
}

### BEGIN
usage() {
    cat <<EOF
Usage: $PROG [-hi] [...paths]

Dead simple cli declarative download tool.

Options:
  -c [name]:  Use name.ini in $ZSHDL_CONFIG_DIR as the config
  -h:         Display this help message and exit


Examples:
  dl
    Parses clipboard for urls to download
  dl "https://gutenberg.org/ebooks/76257" "https://github.com/sumoduduk/terminusdm/tree/main/src"
    Download book #76257 as a markdown file, and the src/ folder of the sumoduduk/terminusdm in the main branch to the current directory
  dl -i media < urls.txt
    Download supported media from urls
EOF

  (($#)) && exit $1
}

EDIT=false
SHOWLOG=false
SCRIPT="$(readlink -f -- "$0")"
PROG="$(basename "$0")"
ZSHDL_VARIANT=default

while getopts "hsev:c:" opt; do
    case "$opt" in
        c)
            CONFIG=($ZSHDL_CONFIG_DIR/$OPTARG*.ini)
            ;;
        e)
            EDIT=true
            ;;  
        v)
            # not perfect but goog enough
            if [[ $OPTARG == -* ]]; then
              VERBOSE=2
              ((OPTIND--))
            else
              VERBOSE=$OPTARG
            fi
            ;;
        h)
            ((VERBOSE>1)) && _display_api
            usage 0
            ;;
        s)
            SHOWLOG=true
            ;;
        *)
            usage 1
            ;;
    esac
done
shift $((OPTIND - 1))

__read_config $CONFIG

if $SHOWLOG; then
  if (($#)); then
    __show_log_entries $@
  else
    __show_log
  fi
  exit
fi

$EDIT && __edit_config $CONFIG

# Begin
LG=$(mktarget -arpv0 dl_lg)
__begin_lg $LG &
LG_ID=$!
exec {lg}> $LG

PP=$(mktarget -arpv0 dl_pp)
__begin_pp $PP | __output &
PP_ID=$!
exec {pp}> $PP

tasks=()
__input $@ | while read -r line && [[ -n $line ]]; do
  (( $#tasks >= $ZSHDL_THREADS )) && __wait_any
  handle $line | __output &
  tasks+=$!
done

exec {pp}>&-
exec {lg}>&-
rm $LG $PP


wait $PP_ID
# wait $LG_ID